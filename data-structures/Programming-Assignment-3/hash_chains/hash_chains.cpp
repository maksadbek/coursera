#include <iostream>#include <string>#include <vector>#include <algorithm>#include <list>using std::string;using std::vector;using std::cin;struct Query {    string type, s;    size_t ind;};struct kv {  string k;  string v;};class Hashtbl {public:  Hashtbl() {};    Hashtbl(size_t m) {    bucket_count = m;    data = std::vector<std::list<kv>>(m, std::list<kv>());  }    void add(string val) {    kv kv;    kv.k = val;    kv.v = val;    find_and_set(kv);    return;  };  string find(string key) {    auto hashed_key = hash_str(key);    for(auto kv : data[hashed_key]) {      if(kv.k == key) {	return "yes";      }    }    return "no";  };  void find_and_set(kv kv) {    auto hashed_key = hash_str(kv.k);    for(auto &node: data[hashed_key]) {      if(node.k == kv.k) {	// if there is already such key in the	// table then ignore it.	return;      }    }    data[hashed_key].push_front(kv);  };  void del(string key) {    auto hashed_key = hash_str(key);    std::list<kv> &list = data[hashed_key];        for(std::list<kv>::iterator it = list.begin(); it != list.end(); it++) {      if((*it).k == key) {	list.erase(it);	break;      }    }        return;  };  std::list<string> check(size_t index) {    std::list<string> result;        for(auto x : data[index]) {      result.push_back(x.v);    }    return result;  }private:  std::vector<std::list<kv>> data;  size_t bucket_count;    size_t hash_str(const string& s) const {    static const size_t multiplier = 263;    static const size_t prime = 1000000007;    unsigned long long hash = 0;    for (int i = static_cast<int> (s.size()) - 1; i >= 0; --i) {      hash = (hash * multiplier + s[i]) % prime;    }        return hash % bucket_count;  }};string join_strings(std::list<string> strs) {  string joined;  for(std::list<string>::iterator it = strs.begin(); it != strs.end(); it++) {    joined += *it;    if(it != std::prev(strs.end())) {      joined += " ";    }  }  return joined;}class QueryProcessor {private:  std::list<string> results;  Hashtbl hashtbl;  public:  QueryProcessor(int bucket_count) {    hashtbl = Hashtbl(bucket_count);  }  Query readQuery() const {    Query query;    cin >> query.type;    if (query.type != "check")      cin >> query.s;    else      cin >> query.ind;    return query;  }  void processQuery(const Query& query) {    if(query.type == "add") {      hashtbl.add(query.s);    } else if (query.type == "del") {      hashtbl.del(query.s);    } else if (query.type == "find") {      results.push_back(hashtbl.find(query.s));    } else if (query.type == "check") {      string r;      auto result = hashtbl.check(query.ind);      if(result.size() == 0) {	r = "";	results.push_back(r);	return;      }      results.push_back(join_strings(result));    }  }  void processQueries() {    int n;    cin >> n;    for (int i = 0; i < n; ++i) {      processQuery(readQuery());    }    for(auto x : results) {      std::cout << x << std::endl;    }  }};int main() {  std::ios_base::sync_with_stdio(false);    int bucket_count;  cin >> bucket_count;    QueryProcessor proc = QueryProcessor(bucket_count);  proc.processQueries();    return 0;}